// Code generated by capnpc-go. DO NOT EDIT.

package main

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	math "math"
)

type StopNode capnp.Struct

// StopNode_TypeID is the unique identifier for the type StopNode.
const StopNode_TypeID = 0xc0b40994ec2c1dbf

func NewStopNode(s *capnp.Segment) (StopNode, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return StopNode(st), err
}

func NewRootStopNode(s *capnp.Segment) (StopNode, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return StopNode(st), err
}

func ReadRootStopNode(msg *capnp.Message) (StopNode, error) {
	root, err := msg.Root()
	return StopNode(root.Struct()), err
}

func (s StopNode) String() string {
	str, _ := text.Marshal(0xc0b40994ec2c1dbf, capnp.Struct(s))
	return str
}

func (s StopNode) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (StopNode) DecodeFromPtr(p capnp.Ptr) StopNode {
	return StopNode(capnp.Struct{}.DecodeFromPtr(p))
}

func (s StopNode) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s StopNode) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s StopNode) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s StopNode) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s StopNode) Latitude() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s StopNode) SetLatitude(v float64) {
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s StopNode) Longitude() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s StopNode) SetLongitude(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

func (s StopNode) Direction() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s StopNode) HasDirection() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s StopNode) DirectionBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s StopNode) SetDirection(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// StopNode_List is a list of StopNode.
type StopNode_List = capnp.StructList[StopNode]

// NewStopNode creates a new list of StopNode.
func NewStopNode_List(s *capnp.Segment, sz int32) (StopNode_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1}, sz)
	return capnp.StructList[StopNode](l), err
}

// StopNode_Future is a wrapper for a StopNode promised by a client call.
type StopNode_Future struct{ *capnp.Future }

func (f StopNode_Future) Struct() (StopNode, error) {
	p, err := f.Future.Ptr()
	return StopNode(p.Struct()), err
}

type Way capnp.Struct

// Way_TypeID is the unique identifier for the type Way.
const Way_TypeID = 0xe96f0c725dd473d2

func NewWay(s *capnp.Segment) (Way, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 72, PointerCount: 5})
	return Way(st), err
}

func NewRootWay(s *capnp.Segment) (Way, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 72, PointerCount: 5})
	return Way(st), err
}

func ReadRootWay(msg *capnp.Message) (Way, error) {
	root, err := msg.Root()
	return Way(root.Struct()), err
}

func (s Way) String() string {
	str, _ := text.Marshal(0xe96f0c725dd473d2, capnp.Struct(s))
	return str
}

func (s Way) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Way) DecodeFromPtr(p capnp.Ptr) Way {
	return Way(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Way) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Way) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Way) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Way) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Way) Name() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Way) HasName() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Way) NameBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Way) SetName(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Way) Ref() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s Way) HasRef() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Way) RefBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s Way) SetRef(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

func (s Way) MaxSpeed() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s Way) SetMaxSpeed(v float64) {
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s Way) MinLat() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s Way) SetMinLat(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

func (s Way) MinLon() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(16))
}

func (s Way) SetMinLon(v float64) {
	capnp.Struct(s).SetUint64(16, math.Float64bits(v))
}

func (s Way) MaxLat() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(24))
}

func (s Way) SetMaxLat(v float64) {
	capnp.Struct(s).SetUint64(24, math.Float64bits(v))
}

func (s Way) MaxLon() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(32))
}

func (s Way) SetMaxLon(v float64) {
	capnp.Struct(s).SetUint64(32, math.Float64bits(v))
}

func (s Way) Nodes() (Coordinates_List, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return Coordinates_List(p.List()), err
}

func (s Way) HasNodes() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Way) SetNodes(v Coordinates_List) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewNodes sets the nodes field to a newly
// allocated Coordinates_List, preferring placement in s's segment.
func (s Way) NewNodes(n int32) (Coordinates_List, error) {
	l, err := NewCoordinates_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Coordinates_List{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}
func (s Way) Lanes() uint8 {
	return capnp.Struct(s).Uint8(40)
}

func (s Way) SetLanes(v uint8) {
	capnp.Struct(s).SetUint8(40, v)
}

func (s Way) AdvisorySpeed() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(48))
}

func (s Way) SetAdvisorySpeed(v float64) {
	capnp.Struct(s).SetUint64(48, math.Float64bits(v))
}

func (s Way) Hazard() (string, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.Text(), err
}

func (s Way) HasHazard() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s Way) HazardBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.TextBytes(), err
}

func (s Way) SetHazard(v string) error {
	return capnp.Struct(s).SetText(3, v)
}

func (s Way) OneWay() bool {
	return capnp.Struct(s).Bit(328)
}

func (s Way) SetOneWay(v bool) {
	capnp.Struct(s).SetBit(328, v)
}

func (s Way) MaxSpeedForward() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(56))
}

func (s Way) SetMaxSpeedForward(v float64) {
	capnp.Struct(s).SetUint64(56, math.Float64bits(v))
}

func (s Way) MaxSpeedBackward() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(64))
}

func (s Way) SetMaxSpeedBackward(v float64) {
	capnp.Struct(s).SetUint64(64, math.Float64bits(v))
}

func (s Way) StopNodes() (StopNode_List, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return StopNode_List(p.List()), err
}

func (s Way) HasStopNodes() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s Way) SetStopNodes(v StopNode_List) error {
	return capnp.Struct(s).SetPtr(4, v.ToPtr())
}

// NewStopNodes sets the stopNodes field to a newly
// allocated StopNode_List, preferring placement in s's segment.
func (s Way) NewStopNodes(n int32) (StopNode_List, error) {
	l, err := NewStopNode_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return StopNode_List{}, err
	}
	err = capnp.Struct(s).SetPtr(4, l.ToPtr())
	return l, err
}

// Way_List is a list of Way.
type Way_List = capnp.StructList[Way]

// NewWay creates a new list of Way.
func NewWay_List(s *capnp.Segment, sz int32) (Way_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 72, PointerCount: 5}, sz)
	return capnp.StructList[Way](l), err
}

// Way_Future is a wrapper for a Way promised by a client call.
type Way_Future struct{ *capnp.Future }

func (f Way_Future) Struct() (Way, error) {
	p, err := f.Future.Ptr()
	return Way(p.Struct()), err
}

type Coordinates capnp.Struct

// Coordinates_TypeID is the unique identifier for the type Coordinates.
const Coordinates_TypeID = 0xbb98485b5b7943a9

func NewCoordinates(s *capnp.Segment) (Coordinates, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Coordinates(st), err
}

func NewRootCoordinates(s *capnp.Segment) (Coordinates, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Coordinates(st), err
}

func ReadRootCoordinates(msg *capnp.Message) (Coordinates, error) {
	root, err := msg.Root()
	return Coordinates(root.Struct()), err
}

func (s Coordinates) String() string {
	str, _ := text.Marshal(0xbb98485b5b7943a9, capnp.Struct(s))
	return str
}

func (s Coordinates) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Coordinates) DecodeFromPtr(p capnp.Ptr) Coordinates {
	return Coordinates(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Coordinates) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Coordinates) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Coordinates) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Coordinates) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Coordinates) Latitude() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s Coordinates) SetLatitude(v float64) {
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s Coordinates) Longitude() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s Coordinates) SetLongitude(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

// Coordinates_List is a list of Coordinates.
type Coordinates_List = capnp.StructList[Coordinates]

// NewCoordinates creates a new list of Coordinates.
func NewCoordinates_List(s *capnp.Segment, sz int32) (Coordinates_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0}, sz)
	return capnp.StructList[Coordinates](l), err
}

// Coordinates_Future is a wrapper for a Coordinates promised by a client call.
type Coordinates_Future struct{ *capnp.Future }

func (f Coordinates_Future) Struct() (Coordinates, error) {
	p, err := f.Future.Ptr()
	return Coordinates(p.Struct()), err
}

type Offline capnp.Struct

// Offline_TypeID is the unique identifier for the type Offline.
const Offline_TypeID = 0xb7b19459e4e55961

func NewOffline(s *capnp.Segment) (Offline, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 40, PointerCount: 1})
	return Offline(st), err
}

func NewRootOffline(s *capnp.Segment) (Offline, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 40, PointerCount: 1})
	return Offline(st), err
}

func ReadRootOffline(msg *capnp.Message) (Offline, error) {
	root, err := msg.Root()
	return Offline(root.Struct()), err
}

func (s Offline) String() string {
	str, _ := text.Marshal(0xb7b19459e4e55961, capnp.Struct(s))
	return str
}

func (s Offline) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Offline) DecodeFromPtr(p capnp.Ptr) Offline {
	return Offline(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Offline) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Offline) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Offline) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Offline) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Offline) MinLat() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s Offline) SetMinLat(v float64) {
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s Offline) MinLon() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s Offline) SetMinLon(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

func (s Offline) MaxLat() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(16))
}

func (s Offline) SetMaxLat(v float64) {
	capnp.Struct(s).SetUint64(16, math.Float64bits(v))
}

func (s Offline) MaxLon() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(24))
}

func (s Offline) SetMaxLon(v float64) {
	capnp.Struct(s).SetUint64(24, math.Float64bits(v))
}

func (s Offline) Ways() (Way_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Way_List(p.List()), err
}

func (s Offline) HasWays() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Offline) SetWays(v Way_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewWays sets the ways field to a newly
// allocated Way_List, preferring placement in s's segment.
func (s Offline) NewWays(n int32) (Way_List, error) {
	l, err := NewWay_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Way_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Offline) Overlap() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(32))
}

func (s Offline) SetOverlap(v float64) {
	capnp.Struct(s).SetUint64(32, math.Float64bits(v))
}

// Offline_List is a list of Offline.
type Offline_List = capnp.StructList[Offline]

// NewOffline creates a new list of Offline.
func NewOffline_List(s *capnp.Segment, sz int32) (Offline_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 40, PointerCount: 1}, sz)
	return capnp.StructList[Offline](l), err
}

// Offline_Future is a wrapper for a Offline promised by a client call.
type Offline_Future struct{ *capnp.Future }

func (f Offline_Future) Struct() (Offline, error) {
	p, err := f.Future.Ptr()
	return Offline(p.Struct()), err
}

const schema_db93c434a5c5d09f = "x\xda\xa4\x94Ah\x1cU\x1c\xc6\xbf\xef\xbd\xd9M\xd2" +
	"l\xd2\x0eo\x04=\x94\x88\xa7ZT\x1a\xdbS(D" +
	"Z\x95ZZ\x9b\xd7Qb)\x82\x8f\xccD\x1773" +
	"\xcb\xec\xdad\xbd\x08\x1e=\x89Fh!\xc5\x08\x09$" +
	"\x10\xb1\x95\x16\x8bR\xac\x90\"B\x85P*(V\xf0" +
	"`\xa1\x82\x07\x05\xef+\xff\xd9fv\xb4'\xe9\xed\xbd" +
	"\xdf\xff\x9b\xf7\xff\xf8\xde\xfb\xcf\xbe]\xea\x19o|\xe4" +
	"[\x05e\x1f\xadT\xbb\xee\xd4\x9d\xdfN-^\xfc\x02" +
	"v\x94\x95\xee\xc7[\xd7W\x0fl~\xf83*\x1c\x00" +
	"\xcc\x0b\xfc\xdcXY\xed?\xcei\x82\xdd\xf5\xc3\x9d\xd3" +
	"\xa7\x8f\x9c\xfdJ\xd4\xaa\xaf\xf6D\xbc\xaen\x9a\xcbJ" +
	"V\x17\xd5<\xd8\xfdz\xf7\x13\x7f,\x0e]\xba\xf6\x1f" +
	"m\xef\xe4\x87\xf4\x97f\xb7\x96\xd5#\xfa3\xb0{\xb3" +
	"u\xeb\xd5\xac\x96\xfe.\xe2\xa1\x92\xb8\"\x92\xab\xfa\x03" +
	"s]\xc4\xfb\xbf\xd1'4\x9e\xec\xa6\xb3\xb3\x8dz\x12" +
	"?\xc5\x19\xd7L\x9a\x13'f\xc7\xf2\xfd\x14i\x1f\xd6" +
	"\x1e\xe0\x11\xf0\xcfM\x00vQ\xd3.+\xfad@\x81" +
	"\xe7\x05\x9e\xd5\xb4+\x8a\xbeR\x01\x15\xe0\x7f\"pI" +
	"\xd3\xae)\xfaZ\x07\xd4\x80\xbf*pY\xd3n(\xd2" +
	"\x0b\xe8\x01\xfe\xfa^\xc0\xaeh\xdak\x8a~\xc5\x0bX" +
	"\x01\xfc\xab\x87\x00{E\xd3n*N\xce\xd5\x93c\xae" +
	"\xcda(\x0e\xa3\xb7M\x93\xfe\xd6-\xfc\xab\xea\x16J" +
	"\xd5\x9d\xf3\xae\xd3\xe2(8\xa5\xc9]\xfdD@\x81\xef" +
	"\xa4g\xe2\xac\xe1\x9a\xdb\xea\"\x03\xd5\xcb\xe0p\x9af" +
	"Q=q\xed\x98-\xc9a\xb0\xc8\xe1\xf1\xa3\x80\xdd\xa3" +
	"i\x0f\x94r\x18?\x09\xd8}\x9a\xf6\xa0b\xb7\xe1\xda" +
	"\xf5\xf6[Q\x0c\xa08\xbe\x91&\xaf\x0b\x04\xe3\xfbZ" +
	"\xde\x8b=lO\xa6\xcd\x17\xd3(\xcf\xbdV\xf4{N" +
	"\xfa=\xabi\xa7J\xfd\x8eK\xbfc\x9a\xf6\x15E\xde" +
	"\x8b\xfdea/i\xda\xd7\xfe\x87\x87\xa8\x9e\xc53\xed" +
	"z\x0a&\xacA\xb1v\xbf\xafi\xc7\x8eX:\xb8m" +
	"\xc9|\xc4\xbd@\xf8>5\xc3%\xf6]\x99s|\x0c" +
	"\x08\x17\x85/\xb30f\xce\xf3(\x10.\x09^\x13\xb9" +
	"f\xfe$\xcc*'\x80pY\xf8\x86pO\xe5\xcf\xc2" +
	"\xac\xe7|E\xf8\x05\xe1\x15\x9d\xbf\x0c\xf3i\xce\xd7\x84" +
	"_\x12^\xf5\x02Ve>r\xbe!\xfc\x8a\xf0\x01\x15" +
	"\xe4Cq\x99O\x03\xe1\x05\xe17\x84\x0f\xee\x098\x08" +
	"\x98\xefr\xbe)|K\xf8P5\xe0\x10`\xbeg\x06" +
	"\x847\x84\xff(|\x87\x0e\xb8\x030?\xe4\xe7o\x09" +
	"\xbfM\xc5\xf1\xe1#\x0c8\x0c\x98\x9f\xf2\xc2-)\xfc" +
	"*\x1f\xd4\x06\x02\xd6\x00\xf3\x0b\xdf\x05\xc2\xdb\xc2\xef\x0a" +
	"\x1f\x19\x0c8\x02\x98;|\x0f\x08\xef\x0a\xff[\xf8\xa8" +
	"\x17p\x140\x7f\xf1$\x10\xfe)\xbc\xa6\x14w&n" +
	".\xde\xbe\x8d\x81,\x9e-nf\xce-\x84\xcd8\x8e" +
	"J\xb7\xfa #2\x96\xa4Q\\\x9a\x91\xe2w\xd4\x9b" +
	"\x91\xb1\x86K\xe2\x16\xabP\xac\x82]\x17\x9d\xa9\xb7\xd2" +
	"\xac\x83\xb1\xdcCq\xe6\x1b\xeem\x97E\xdb\x1e'\xd3" +
	"$\x9ev\x1d\x12\x8a,Y\xe6\xf3i6\xef\xb2\xa8\xff" +
	"\x1c\x8b\xca!7\xf3f^\xea\xd7Z\xed\xde(\x80%" +
	"{\xc5\x1f\xb0g\xef\x9f\x00\x00\x00\xff\xff\x8f\xb6$\xf6"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_db93c434a5c5d09f,
		Nodes: []uint64{
			0xb7b19459e4e55961,
			0xbb98485b5b7943a9,
			0xc0b40994ec2c1dbf,
			0xe96f0c725dd473d2,
		},
		Compressed: true,
	})
}
